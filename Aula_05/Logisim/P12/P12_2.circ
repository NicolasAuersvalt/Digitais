<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project source="3.7.2" version="1.0">
  This file is intended to be loaded by Logisim-evolution v3.7.2(https://github.com/logisim-evolution/).

  <lib desc="#Wiring" name="0">
    <tool name="Pin">
      <a name="appearance" val="classic"/>
    </tool>
  </lib>
  <lib desc="#Gates" name="1"/>
  <lib desc="#Plexers" name="2"/>
  <lib desc="#Arithmetic" name="3"/>
  <lib desc="#Memory" name="4"/>
  <lib desc="#I/O" name="5"/>
  <lib desc="#TTL" name="6"/>
  <lib desc="#TCL" name="7"/>
  <lib desc="#Base" name="8">
    <tool name="Text Tool">
      <a name="font" val="SansSerif plain 12"/>
    </tool>
  </lib>
  <lib desc="#BFH-Praktika" name="9"/>
  <lib desc="#Input/Output-Extra" name="10"/>
  <lib desc="#Soc" name="11"/>
  <main name="P0_FFD"/>
  <options>
    <a name="gateUndefined" val="ignore"/>
    <a name="simlimit" val="1000"/>
    <a name="simrand" val="0"/>
  </options>
  <mappings>
    <tool lib="8" map="Button2" name="Menu Tool"/>
    <tool lib="8" map="Button3" name="Menu Tool"/>
    <tool lib="8" map="Ctrl Button1" name="Menu Tool"/>
  </mappings>
  <toolbar>
    <tool lib="8" name="Poke Tool"/>
    <tool lib="8" name="Edit Tool"/>
    <tool lib="8" name="Wiring Tool"/>
    <tool lib="8" name="Text Tool">
      <a name="font" val="SansSerif plain 12"/>
    </tool>
    <sep/>
    <tool lib="0" name="Pin"/>
    <tool lib="0" name="Pin">
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
    </tool>
    <sep/>
    <tool lib="1" name="NOT Gate">
      <a name="facing" val="north"/>
    </tool>
    <tool lib="1" name="AND Gate"/>
    <tool lib="1" name="OR Gate">
      <a name="facing" val="north"/>
    </tool>
    <tool lib="1" name="XOR Gate"/>
    <tool lib="1" name="NAND Gate">
      <a name="facing" val="west"/>
    </tool>
    <tool lib="1" name="NOR Gate"/>
    <sep/>
    <tool lib="4" name="D Flip-Flop"/>
    <tool lib="4" name="Register"/>
  </toolbar>
  <circuit name="P0_FFD">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="P0_FFD"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="simulationFrequency" val="8.0"/>
    <comp lib="8" loc="(214,98)" name="Text">
      <a name="font" val="SansSerif plain 12"/>
      <a name="text" val="Este bloco de entidade VHDL contém duas entidades VHDL:"/>
    </comp>
    <comp lib="8" loc="(238,148)" name="Text">
      <a name="font" val="SansSerif plain 12"/>
      <a name="text" val="A segunda chmada &quot;ffd_vhdl&quot;, que será usada em todo este projeto:"/>
    </comp>
    <comp lib="8" loc="(246,123)" name="Text">
      <a name="font" val="SansSerif plain 12"/>
      <a name="text" val="A primeira chamada &quot;comps&quot;, que será renomeada e que não faz nada:"/>
    </comp>
    <comp loc="(40,40)" name="comps">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
  </circuit>
  <circuit name="P1_cnt_mod16_up">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="P1_cnt_mod16_up"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="simulationFrequency" val="8.0"/>
    <comp lib="0" loc="(120,330)" name="Clock">
      <a name="label" val="CLK"/>
    </comp>
    <comp lib="0" loc="(120,600)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="label" val="UD"/>
    </comp>
    <comp lib="1" loc="(270,350)" name="NOT Gate">
      <a name="facing" val="north"/>
    </comp>
    <comp lib="1" loc="(390,250)" name="AND Gate">
      <a name="size" val="30"/>
    </comp>
    <comp lib="4" loc="(250,230)" name="D Flip-Flop">
      <a name="appearance" val="logisim_evolution"/>
      <a name="label" val="FFT_SST"/>
    </comp>
    <comp lib="5" loc="(120,280)" name="Button">
      <a name="label" val="SST"/>
      <a name="press" val="passive"/>
    </comp>
    <comp lib="5" loc="(120,390)" name="Button">
      <a name="label" val="Z"/>
      <a name="press" val="passive"/>
    </comp>
    <comp lib="5" loc="(800,300)" name="Hex Digit Display">
      <a name="labelvisible" val="true"/>
    </comp>
    <comp lib="5" loc="(850,300)" name="Hex Digit Display">
      <a name="labelvisible" val="true"/>
    </comp>
    <comp lib="5" loc="(910,300)" name="Hex Digit Display">
      <a name="labelvisible" val="true"/>
    </comp>
    <comp lib="5" loc="(960,300)" name="Hex Digit Display">
      <a name="labelvisible" val="true"/>
    </comp>
    <comp loc="(750,490)" name="cnt_up_down_mod6_vhdl">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(760,620)" name="cnt_up_down_mod60_vhdl">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(770,370)" name="cnt_up_down_mod10_vhdl">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <wire from="(1010,310)" to="(1010,640)"/>
    <wire from="(120,280)" to="(150,280)"/>
    <wire from="(120,330)" to="(180,330)"/>
    <wire from="(120,390)" to="(270,390)"/>
    <wire from="(120,600)" to="(220,600)"/>
    <wire from="(150,280)" to="(150,680)"/>
    <wire from="(150,280)" to="(240,280)"/>
    <wire from="(150,680)" to="(540,680)"/>
    <wire from="(180,330)" to="(180,620)"/>
    <wire from="(180,330)" to="(350,330)"/>
    <wire from="(180,620)" to="(540,620)"/>
    <wire from="(220,410)" to="(220,600)"/>
    <wire from="(220,410)" to="(550,410)"/>
    <wire from="(220,600)" to="(220,660)"/>
    <wire from="(220,600)" to="(500,600)"/>
    <wire from="(220,660)" to="(540,660)"/>
    <wire from="(230,190)" to="(230,240)"/>
    <wire from="(230,190)" to="(320,190)"/>
    <wire from="(230,240)" to="(240,240)"/>
    <wire from="(270,290)" to="(270,350)"/>
    <wire from="(270,380)" to="(270,390)"/>
    <wire from="(270,390)" to="(270,510)"/>
    <wire from="(270,390)" to="(550,390)"/>
    <wire from="(270,510)" to="(270,640)"/>
    <wire from="(270,510)" to="(530,510)"/>
    <wire from="(270,640)" to="(540,640)"/>
    <wire from="(300,240)" to="(360,240)"/>
    <wire from="(300,280)" to="(320,280)"/>
    <wire from="(320,190)" to="(320,280)"/>
    <wire from="(350,260)" to="(350,330)"/>
    <wire from="(350,260)" to="(360,260)"/>
    <wire from="(390,250)" to="(520,250)"/>
    <wire from="(480,460)" to="(480,490)"/>
    <wire from="(480,460)" to="(770,460)"/>
    <wire from="(480,490)" to="(530,490)"/>
    <wire from="(500,530)" to="(500,600)"/>
    <wire from="(500,530)" to="(530,530)"/>
    <wire from="(520,250)" to="(520,370)"/>
    <wire from="(520,370)" to="(550,370)"/>
    <wire from="(750,490)" to="(900,490)"/>
    <wire from="(760,620)" to="(960,620)"/>
    <wire from="(760,640)" to="(1010,640)"/>
    <wire from="(770,370)" to="(850,370)"/>
    <wire from="(770,390)" to="(770,460)"/>
    <wire from="(800,300)" to="(800,310)"/>
    <wire from="(800,310)" to="(900,310)"/>
    <wire from="(850,300)" to="(850,370)"/>
    <wire from="(900,310)" to="(900,490)"/>
    <wire from="(910,300)" to="(910,310)"/>
    <wire from="(910,310)" to="(1010,310)"/>
    <wire from="(960,300)" to="(960,620)"/>
  </circuit>
  <vhdl name="comps">--------------------------------------------------------------------------------
-- UTFPR - Universidade Tecnológica Federal do Paraná - Curitiba - PR
-- Projeto  : Prática 5 - Cronômetro
-- Circuito : Implementação de um FF tipo D
-- Arquivo  : dff_vhdl.vhd
-- Autor    : prof. Gortan
-- Data     : Outubro 2021
--------------------------------------------------------------------------------
-- Descrição :
-- Implementa um flip-flop tipo D para ser usado como componente em outros circ.
-- obs.: para evitar que o Logisim-evolution 3.6.1 altere o nome do componente
--       introduzimos um componente "comps" no início do arquivo e o ff tipo d
--       vem em segundo lugar - No Quartus ele deve ser comentado / apagado
--------------------------------------------------------------------------------

--============================= Módulo comps: ==================================
library ieee;
  use ieee.std_logic_1164.all;

-- Comentar a entity comps e sua architecture quando usado no Quartus
-- Esse primeira entity é só um artifício para evitar que o Logisim
-- altere o nome do componente ff tipo d, que vem depois
entity comps is
  port(    a  : in  std_logic );
end comps;

architecture cmp_arch of comps is
-- Não faz nada:
begin
end cmp_arch;
-- Fim do trecho a comentar/apagar no Quartus

--==================== Componente: =============================================
library ieee;
  use ieee.std_logic_1164.all;

entity dff_vhdl is
  port(
    d, clk, prs, clr	: in  std_logic;	-- entradas: dado, clk, preset e clear
    q, qn				: out std_logic		-- saídas:   q e q invertido
 );
end dff_vhdl;

architecture ff_d of dff_vhdl is

	signal qstate: std_logic;

begin
	process(clk, clr, prs)
	begin
		if clr = '1' then qstate &lt;= '0';
		elsif prs = '1' then qstate &lt;= '1';
		elsif clk = '1' and clk' event then qstate &lt;= d;
		end if;
	end process;
	q &lt;= qstate;
	qn &lt;= not qstate;
end ff_d;

</vhdl>
  <vhdl name="cnt_up_down_mod10_vhdl">library ieee;
use ieee.std_logic_1164.all;
	
entity cnt_up_down_mod10_vhdl is
	port(
		clk, z, ud	: in  std_logic;					
	    	q       		: out std_logic_vector(3 downto 0);	
	    	co 			: out std_logic
	 );
end cnt_up_down_mod10_vhdl;
	
architecture nt_up_down_mod10_arch of cnt_up_down_mod10_vhdl is
	signal q_up, q_down, qstate_up, qstate_down, qn_up, qn_down: std_logic_vector(3 downto 0);
	signal clk_up, clk_down, clkn_up, clkn_down, rst, zn, reset, ff_rst_in, ff_rst_out, rst_alargador, ff_rst, clr_alargador, clr_aux, prs_rst: std_logic;	
	component dff_vhdl is					-- dff referenciado como dff_vhdl
		port(
			d, clk, prs, clr	: in  std_logic;	-- entradas: dado, clk, preset e clear
			q, qn			: out std_logic 	-- saídas:   q e q invertido
		);
	end component;
begin
	q(0) &lt;= q_up(0) when ud = '0' else q_down(0);
	q(1) &lt;= q_up(1) when ud = '0' else q_down(1);
	q(2) &lt;= q_up(2) when ud = '0' else q_down(2);
	q(3) &lt;= q_up(3) when ud = '0' else q_down(3);
	zn &lt;= not z;
	clk_up &lt;= clk when ud = '0';
	clk_down &lt;= clk when ud = '1';
	clkn_up &lt;= not clk_up;
	clkn_down &lt;= not clk_down;
	prs_rst &lt;= (zn or (qstate_up(1) and qstate_up(3)));
	ff_d0_up: dff_vhdl port map(d =&gt; qn_up(0), prs =&gt; '0', clr =&gt; clr_aux, clk =&gt; clk_up,   q =&gt; qstate_up(0), qn =&gt; qn_up(0));
	ff_d1_up: dff_vhdl port map(d =&gt; qn_up(1), prs =&gt; '0', clr =&gt; clr_aux, clk =&gt; qn_up(0), q =&gt; qstate_up(1), qn =&gt; qn_up(1));
	ff_d2_up: dff_vhdl port map(d =&gt; qn_up(2), prs =&gt; '0', clr =&gt; clr_aux, clk =&gt; qn_up(1), q =&gt; qstate_up(2), qn =&gt; qn_up(2));
	ff_d3_up: dff_vhdl port map(d =&gt; qn_up(3), prs =&gt; '0', clr =&gt; clr_aux, clk =&gt; qn_up(2), q =&gt; qstate_up(3), qn =&gt; qn_up(3));
	ff_rst_up: dff_vhdl port map(d =&gt; '0', prs =&gt; prs_rst, clr =&gt; clkn_up, clk =&gt; '0', q =&gt; clr_aux);
	q_up(0) &lt;= qstate_up(0);
	q_up(1) &lt;= qstate_up(1);
	q_up(2) &lt;= qstate_up(2);
	q_up(3) &lt;= qstate_up(3);
	reset &lt;= ff_rst_out and (qstate_down(0) and (qstate_down(1) and (qstate_down(2) and qstate_down(3))));
	ff_rst_in &lt;= not (qstate_down(0) or (qstate_down(1) or (qstate_down(2) or qstate_down(3))));
	rst_alargador &lt;= reset or zn;
	ff_d0_down: dff_vhdl port map(d =&gt; qn_down(0), prs =&gt; rst, clr =&gt; '0', clk =&gt; clk_down, q =&gt; qstate_down(0), qn =&gt; qn_down(0));
	ff_d1_down: dff_vhdl port map(d =&gt; qn_down(1), prs =&gt; '0', clr =&gt; ff_rst, clk =&gt; qstate_down(0), q =&gt; qstate_down(1), qn =&gt; qn_down(1));
	ff_d2_down: dff_vhdl port map(d =&gt; qn_down(2), prs =&gt; '0', clr =&gt; ff_rst, clk =&gt; qstate_down(1), q =&gt; qstate_down(2), qn =&gt; qn_down(2));
	ff_d3_down: dff_vhdl port map(d =&gt; qn_down(3), prs =&gt; rst, clr =&gt; '0', clk =&gt; qstate_down(2), q =&gt; qstate_down(3), qn =&gt; qn_down(3));
	ff_rst_down: dff_vhdl port map(d =&gt; '0', prs =&gt; ff_rst_in, clr =&gt; ff_rst, clk =&gt; '0', q =&gt; ff_rst_out);
	ff_rst_alargador_down: dff_vhdl   port map(d =&gt; '0', prs =&gt; rst_alargador, clr =&gt; clkn_down, clk =&gt; '0', q =&gt; ff_rst);
	ff_rst_alargador_clr_down: dff_vhdl port map(d =&gt; '0', prs =&gt; zn, clr =&gt; clkn_down, clk =&gt; '0', q =&gt; clr_alargador);
	rst &lt;= '1' when clr_alargador = '1' else '0';
	q_down(0) &lt;= qstate_down(0);
	q_down(1) &lt;= qstate_down(1);
	q_down(2) &lt;= qstate_down(2);
	q_down(3) &lt;= qstate_down(3);
	co &lt;= clr_aux when ud = '0' else ff_rst;
end nt_up_down_mod10_arch;</vhdl>
  <vhdl name="cnt_up_down_mod6_vhdl">library ieee;
use ieee.std_logic_1164.all;

entity cnt_up_down_mod6_vhdl is
	port(
    		clk, z, ud	: in  std_logic;					
    		q       		: out std_logic_vector(3 downto 0)	
	 );
end cnt_up_down_mod6_vhdl;

architecture P12_cnt_up_down_mod6_arch of cnt_up_down_mod6_vhdl is
	signal q_up, q_down, qstate_up, qstate_down, qn_up, qn_down: std_logic_vector(3 downto 0);
	signal clk_up, clk_down, clkn_up, clkn_down, rst, zn, reset, ff_rst_in, ff_rst_out, rst_alargador, ff_rst, clr_alargador, clr_aux, prs_rst: std_logic;
	component dff_vhdl is					
		port(
			d, clk, prs, clr	: in  std_logic;	
			q, qn			: out std_logic
		);
	end component;
begin
	q(0) &lt;= q_up(0) when ud = '0' else q_down(0);
	q(1) &lt;= q_up(1) when ud = '0' else q_down(1);
	q(2) &lt;= q_up(2) when ud = '0' else q_down(2);
	q(3) &lt;= q_up(3) when ud = '0' else q_down(3);
	zn &lt;= not z;
	clk_up &lt;= clk when ud = '0';
	clk_down &lt;= clk when ud = '1';
	clkn_up &lt;= not clk_up;
	clkn_down &lt;= not clk_down;
	prs_rst &lt;= (zn or (qstate_up(1) and qstate_up(2)));
	ff_d0_up:  dff_vhdl port map(d =&gt; qn_up(0), prs =&gt; '0',     clr =&gt; clr_aux, clk =&gt; clk_up,   q =&gt; qstate_up(0), qn =&gt; qn_up(0));
	ff_d1_up:  dff_vhdl port map(d =&gt; qn_up(1), prs =&gt; '0',     clr =&gt; clr_aux, clk =&gt; qn_up(0), q =&gt; qstate_up(1), qn =&gt; qn_up(1));
	ff_d2_up:  dff_vhdl port map(d =&gt; qn_up(2), prs =&gt; '0',     clr =&gt; clr_aux, clk =&gt; qn_up(1), q =&gt; qstate_up(2), qn =&gt; qn_up(2));
	ff_d3_up:  dff_vhdl port map(d =&gt; qn_up(3), prs =&gt; '0',     clr =&gt; clr_aux, clk =&gt; qn_up(2), q =&gt; qstate_up(3), qn =&gt; qn_up(3));
	ff_rst_up: dff_vhdl port map(d =&gt; '0',      prs =&gt; prs_rst, clr =&gt; clkn_up, clk =&gt; '0',      q =&gt; clr_aux);
	q_up(0) &lt;= qstate_up(0);
	q_up(1) &lt;= qstate_up(1);
	q_up(2) &lt;= qstate_up(2);
	q_up(3) &lt;= qstate_up(3);
	reset &lt;= (qstate_down(0) and (qstate_down(1) and (qstate_down(2) and qstate_down(3))));
	rst_alargador &lt;= reset or zn;
	ff_d0_down: dff_vhdl port map(d =&gt; qn_down(0), prs =&gt; rst, clr =&gt; '0',    clk =&gt; clk_down,       q =&gt; qstate_down(0), qn =&gt; qn_down(0));
	ff_d1_down: dff_vhdl port map(d =&gt; qn_down(1), prs =&gt; '0', clr =&gt; ff_rst, clk =&gt; qstate_down(0), q =&gt; qstate_down(1), qn =&gt; qn_down(1));
	ff_d2_down: dff_vhdl port map(d =&gt; qn_down(2), prs =&gt; rst, clr =&gt; '0', clk =&gt; qstate_down(1), q =&gt; qstate_down(2), qn =&gt; qn_down(2));
	ff_d3_down: dff_vhdl port map(d =&gt; qn_down(3), prs =&gt; '0', clr =&gt; ff_rst,    clk =&gt; qstate_down(2), q =&gt; qstate_down(3), qn =&gt; qn_down(3));
	ff_rst_alargador_down: dff_vhdl port map(d =&gt; '0', prs =&gt; rst_alargador, clr =&gt; clkn_down, clk =&gt; '0', q =&gt; ff_rst);
	ff_rst_clr_alargador_down: dff_vhdl port map(d =&gt; '0', prs =&gt; zn, clr =&gt; clkn_down, clk =&gt; '0', q =&gt; clr_alargador);
	rst &lt;= '1' when clr_alargador = '1' else '0';
	q_down(0) &lt;= qstate_down(0);
	q_down(1) &lt;= qstate_down(1);
	q_down(2) &lt;= qstate_down(2);
	q_down(3) &lt;= qstate_down(3);
end P12_cnt_up_down_mod6_arch;</vhdl>
  <vhdl name="cnt_up_down_mod60_vhdl">library ieee;
use ieee.std_logic_1164.all;

entity cnt_up_down_mod60_vhdl is
	port(
    		clk, z, ud, sst  	: in  std_logic;					
    		qu, qd       		: out std_logic_vector(3 downto 0)	

 );
end cnt_up_down_mod60_vhdl;

architecture cnt_up_down_mod60_arch of cnt_up_down_mod60_vhdl is
	signal ff_rst_in, ff_rst_out, qo: std_logic;
	signal q_up_m10, q_down_m10, qstate_up_m10, qstate_down_m10, qn_up_m10, qn_down_m10: std_logic_vector(3 downto 0);
	signal clk_up_m10, clk_down_m10, clkn_up_m10, clkn_down_m10, rst_m10, zn_m10, reset_m10, rst_alargador_m10, ff_rst_m10, clr_alargador_m10, clr_aux_m10, prs_rst_m10: std_logic;
	signal q_up_m6, q_down_m6, qstate_up_m6, qstate_down_m6, qn_up_m6, qn_down_m6: std_logic_vector(3 downto 0);
	signal clk_up_m6, clk_down_m6, clkn_up_m6, clkn_down_m6, rst_m6, zn_m6, reset_m6, rst_alargador_m6, ff_rst_m6, clr_alargador_m6, clr_aux_m6, prs_rst_m6: std_logic;
	component dff_vhdl is					
		port(
			d, clk, prs, clr	: in  std_logic;	
			q, qn			: out std_logic 	
		);
	end component;	
begin
	qu(0) &lt;= q_up_m10(0) when ud = '0' else q_down_m10(0);
	qu(1) &lt;= q_up_m10(1) when ud = '0' else q_down_m10(1);
	qu(2) &lt;= q_up_m10(2) when ud = '0' else q_down_m10(2);
	qu(3) &lt;= q_up_m10(3) when ud = '0' else q_down_m10(3);
	zn_m10 &lt;= not z;
	clk_up_m10 &lt;= clk when ud = '0';
	clk_down_m10 &lt;= clk when ud = '1';
	clkn_up_m10 &lt;= not clk_up_m10;
	clkn_down_m10 &lt;= not clk_down_m10;
	prs_rst_m10 &lt;= (zn_m10 or (qstate_up_m10(1) and qstate_up_m10(3)));
	ff_d0_up_m10: dff_vhdl port map(d =&gt; qn_up_m10(0), prs =&gt; '0', clr =&gt; clr_aux_m10, clk =&gt; clk_up_m10,   q =&gt; qstate_up_m10(0), qn =&gt; qn_up_m10(0));
	ff_d1_up_m10: dff_vhdl port map(d =&gt; qn_up_m10(1), prs =&gt; '0', clr =&gt; clr_aux_m10, clk =&gt; qn_up_m10(0), q =&gt; qstate_up_m10(1), qn =&gt; qn_up_m10(1));
	ff_d2_up_m10: dff_vhdl port map(d =&gt; qn_up_m10(2), prs =&gt; '0', clr =&gt; clr_aux_m10, clk =&gt; qn_up_m10(1), q =&gt; qstate_up_m10(2), qn =&gt; qn_up_m10(2));
	ff_d3_up_m10: dff_vhdl port map(d =&gt; qn_up_m10(3), prs =&gt; '0', clr =&gt; clr_aux_m10, clk =&gt; qn_up_m10(2), q =&gt; qstate_up_m10(3), qn =&gt; qn_up_m10(3));
	ff_rst_up_m10: dff_vhdl port map(d =&gt; '0', prs =&gt; prs_rst_m10, clr =&gt; clkn_up_m10, clk =&gt; '0', q =&gt; clr_aux_m10);
	q_up_m10(0) &lt;= qstate_up_m10(0);
	q_up_m10(1) &lt;= qstate_up_m10(1);
	q_up_m10(2) &lt;= qstate_up_m10(2);
	q_up_m10(3) &lt;= qstate_up_m10(3);
	reset_m10 &lt;= ff_rst_out and (qstate_down_m10(0) and (qstate_down_m10(1) and (qstate_down_m10(2) and qstate_down_m10(3))));
	ff_rst_in &lt;= not (qstate_down_m10(0) or (qstate_down_m10(1) or (qstate_down_m10(2) or qstate_down_m10(3))));
	rst_alargador_m10 &lt;= reset_m10 or zn_m10;
	ff_d0_down_m10: dff_vhdl port map(d =&gt; qn_down_m10(0), prs =&gt; rst_m10, clr =&gt; '0', clk =&gt; clk_down_m10, q =&gt; qstate_down_m10(0), qn =&gt; qn_down_m10(0));
	ff_d1_down_m10: dff_vhdl port map(d =&gt; qn_down_m10(1), prs =&gt; '0', clr =&gt; ff_rst_m10, clk =&gt; qstate_down_m10(0), q =&gt; qstate_down_m10(1), qn =&gt; qn_down_m10(1));
	ff_d2_down_m10: dff_vhdl port map(d =&gt; qn_down_m10(2), prs =&gt; '0', clr =&gt; ff_rst_m10, clk =&gt; qstate_down_m10(1), q =&gt; qstate_down_m10(2), qn =&gt; qn_down_m10(2));
	ff_d3_down_m10: dff_vhdl port map(d =&gt; qn_down_m10(3), prs =&gt; rst_m10, clr =&gt; '0', clk =&gt; qstate_down_m10(2), q =&gt; qstate_down_m10(3), qn =&gt; qn_down_m10(3));
	ff_rst_down_m10: dff_vhdl port map(d =&gt; '0', prs =&gt; ff_rst_in, clr =&gt; ff_rst_m10, clk =&gt; '0', q =&gt; ff_rst_out);
	ff_rst_alargador_down_m10: dff_vhdl port map(d =&gt; '0', prs =&gt; rst_alargador_m10, clr =&gt; clkn_down_m10, clk =&gt; '0', q =&gt; ff_rst_m10);
	ff_rst_alargador_clr_down_m10: dff_vhdl port map(d =&gt; '0', prs =&gt; zn_m10, clr =&gt; clkn_down_m10, clk =&gt; '0', q =&gt; clr_alargador_m10);
	rst_m10 &lt;= '1' when clr_alargador_m10 = '1' else '0';
	q_down_m10(0) &lt;= qstate_down_m10(0);
	q_down_m10(1) &lt;= qstate_down_m10(1);
	q_down_m10(2) &lt;= qstate_down_m10(2);
	q_down_m10(3) &lt;= qstate_down_m10(3);
	qo &lt;= clr_aux_m10 when ud = '0' else ff_rst_m10;
	qd(0) &lt;= q_up_m6(0) when ud = '0' else q_down_m6(0);
	qd(1) &lt;= q_up_m6(1) when ud = '0' else q_down_m6(1);
	qd(2) &lt;= q_up_m6(2) when ud = '0' else q_down_m6(2);
	qd(3) &lt;= q_up_m6(3) when ud = '0' else q_down_m6(3);
	zn_m6 &lt;= not z;
	clk_up_m6 &lt;= qo when ud = '0';
	clk_down_m6 &lt;= qo when ud = '1';
	clkn_up_m6 &lt;= not clk_up_m6;
	clkn_down_m6 &lt;= not clk_down_m6;
	prs_rst_m6 &lt;= (zn_m6 or (qstate_up_m6(1) and qstate_up_m6(3)));
	ff_d0_up_m6: dff_vhdl port map(d =&gt; qn_up_m6(0), prs =&gt; '0', clr =&gt; clr_aux_m6, clk =&gt; clk_up_m6,   q =&gt; qstate_up_m6(0), qn =&gt; qn_up_m6(0));
	ff_d1_up_m6: dff_vhdl port map(d =&gt; qn_up_m6(1), prs =&gt; '0', clr =&gt; clr_aux_m6, clk =&gt; qn_up_m6(0), q =&gt; qstate_up_m6(1), qn =&gt; qn_up_m6(1));
	ff_d2_up_m6: dff_vhdl port map(d =&gt; qn_up_m6(2), prs =&gt; '0', clr =&gt; clr_aux_m6, clk =&gt; qn_up_m6(1), q =&gt; qstate_up_m6(2), qn =&gt; qn_up_m6(2));
	ff_d3_up_m6: dff_vhdl port map(d =&gt; qn_up_m6(3), prs =&gt; '0', clr =&gt; clr_aux_m6, clk =&gt; qn_up_m6(2), q =&gt; qstate_up_m6(3), qn =&gt; qn_up_m6(3));
	ff_rst_up_m6: dff_vhdl port map(d =&gt; '0', prs =&gt; prs_rst_m6, clr =&gt; clkn_up_m6, clk =&gt; '0', q =&gt; clr_aux_m6);
	q_up_m6(0) &lt;= qstate_up_m6(0);
	q_up_m6(1) &lt;= qstate_up_m6(1);
	q_up_m6(2) &lt;= qstate_up_m6(2);
	q_up_m6(3) &lt;= qstate_up_m6(3);
	reset_m6 &lt;= qstate_down_m6(0) and (qstate_down_m6(1) and (qstate_down_m6(2) and qstate_down_m6(3)));
	rst_alargador_m6 &lt;= reset_m6 or zn_m6;
	ff_d0_down_m6: dff_vhdl port map(d =&gt; qn_down_m6(0), prs =&gt; rst_m6, clr =&gt; '0', clk =&gt; clk_down_m6, q =&gt; qstate_down_m6(0), qn =&gt; qn_down_m6(0));
	ff_d1_down_m6: dff_vhdl port map(d =&gt; qn_down_m6(1), prs =&gt; '0', clr =&gt; ff_rst_m6, clk =&gt; qstate_down_m6(0), q =&gt; qstate_down_m6(1), qn =&gt; qn_down_m6(1));
	ff_d2_down_m6: dff_vhdl port map(d =&gt; qn_down_m6(2), prs =&gt; rst_m6, clr =&gt; '0', clk =&gt; qstate_down_m6(1), q =&gt; qstate_down_m6(2), qn =&gt; qn_down_m6(2));
	ff_d3_down_m6: dff_vhdl port map(d =&gt; qn_down_m6(3), prs =&gt; '0', clr =&gt; ff_rst_m6, clk =&gt; qstate_down_m6(2), q =&gt; qstate_down_m6(3), qn =&gt; qn_down_m6(3));
	ff_rst_alargador_down_m6: dff_vhdl port map(d =&gt; '0', prs =&gt; rst_alargador_m6, clr =&gt; clkn_down_m6, clk =&gt; '0', q =&gt; ff_rst_m6);
	ff_rst_alargador_clr_down_m6: dff_vhdl port map(d =&gt; '0', prs =&gt; zn_m6, clr =&gt; clkn_down_m6, clk =&gt; '0', q =&gt; clr_alargador_m6);
	rst_m6 &lt;= '1' when clr_alargador_m6 = '1' else '0';
	q_down_m6(0) &lt;= qstate_down_m6(0);
	q_down_m6(1) &lt;= qstate_down_m6(1);
	q_down_m6(2) &lt;= qstate_down_m6(2);
	q_down_m6(3) &lt;= qstate_down_m6(3);
end cnt_up_down_mod60_arch;</vhdl>
</project>
